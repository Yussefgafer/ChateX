<<<<<<< SEARCH
    data class PendingFileTransfer(
        val fileId: String,
        val fileName: String,
        val totalSize: Long,
        val senderId: String,
        val totalChunks: Int,
        val chunks: Array<ByteArray>
    )

    fun initiateFileTransfer(endpointId: String, file: File, recipientId: String) {
=======
    data class PendingFileTransfer(
        val fileId: String,
        val fileName: String,
        val totalSize: Long,
        val senderId: String,
        val totalChunks: Int,
        var chunksReceived: Int = 0,
        val tempFile: File
    )

    fun initiateFileTransfer(endpointId: String, file: File, recipientId: String) {
>>>>>>> REPLACE
<<<<<<< SEARCH
    private fun splitFileIntoChunks(file: File): List<ByteArray> {
        val chunks = mutableListOf<ByteArray>()
        val inputStream = FileInputStream(file)
        val buffer = ByteArray(CHUNK_SIZE)

        while (true) {
            val bytesRead = inputStream.read(buffer)
            if (bytesRead <= 0) break
            chunks.add(buffer.copyOf(bytesRead))
        }

        inputStream.close()
        return chunks
    }

    private fun sendFileMetadata(endpointId: String, fileId: String, fileName: String, fileSize: Long, recipientId: String, totalChunks: Int) {
        val metadata = FileMetadata(fileId, fileName, fileSize, recipientId, totalChunks)
        val payload = Payload.fromBytes(gson.toJson(metadata).toByteArray(StandardCharsets.UTF_8))
        connectionsClient.sendPayload(endpointId, payload)
            .addOnFailureListener { e -> Log.e(TAG, "Failed to send file metadata", e) }
    }

    private fun sendChunk(endpointId: String, fileId: String, chunkIndex: Int, chunk: ByteArray, recipientId: String, totalChunks: Int) {
=======
    private fun splitFileIntoChunks(file: File): List<ByteArray> {
        val chunks = mutableListOf<ByteArray>()
        FileInputStream(file).use { inputStream ->
            val buffer = ByteArray(CHUNK_SIZE)
            while (true) {
                val bytesRead = inputStream.read(buffer)
                if (bytesRead <= 0) break
                chunks.add(buffer.copyOf(bytesRead))
            }
        }
        return chunks
    }

    private fun sendFileMetadata(endpointId: String, fileId: String, fileName: String, fileSize: Long, recipientId: String, totalChunks: Int) {
        val metadata = FileMetadata(fileId, fileName, fileSize, recipientId, totalChunks)
        val payload = Payload.fromBytes(gson.toJson(metadata).toByteArray(StandardCharsets.UTF_8))
        connectionsClient.sendPayload(endpointId, payload)
            .addOnFailureListener { e -> Log.e(TAG, "Failed to send file metadata", e) }
    }

    private fun sendChunk(endpointId: String, fileId: String, chunkIndex: Int, chunk: ByteArray, recipientId: String, totalChunks: Int) {
>>>>>>> REPLACE
<<<<<<< SEARCH
    fun receiveFileChunk(payload: Payload) {
        payload.asBytes()?.let { bytes ->
            val json = String(bytes, StandardCharsets.UTF_8)

            try {
                val chunkData = gson.fromJson(json, FileChunk::class.java)
                pendingFiles[chunkData.fileId]?.let { pending ->
                    pending.chunks[chunkData.chunkIndex] = chunkData.data

                    val received = pending.chunks.count { it.isNotEmpty() }
                    val progress = received.toFloat() / pending.totalChunks
                    onFileProgress(pending.fileName, pending.senderId, progress)

                    if (received == pending.totalChunks) {
                        reconstructFile(pending)
                    }
                }
            } catch (e: Exception) {
                try {
                    val metadata = gson.fromJson(json, FileMetadata::class.java)
                    pendingFiles[metadata.fileId] = PendingFileTransfer(
                        fileId = metadata.fileId,
                        fileName = metadata.fileName,
                        totalSize = metadata.fileSize,
                        senderId = metadata.senderId,
                        totalChunks = metadata.totalChunks,
                        chunks = Array(metadata.totalChunks) { ByteArray(0) }
                    )
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to parse file data", e)
                }
            }
        }
    }

    private fun reconstructFile(pending: PendingFileTransfer) {
        try {
            // Fix: Sanitize fileName to prevent Path Traversal attacks
            val sanitizedFileName = File(pending.fileName).name
            val outputFile = File(context.cacheDir, "received_$sanitizedFileName")
            val outputStream = FileOutputStream(outputFile)

            pending.chunks.forEach { chunk ->
                if (chunk.isNotEmpty()) {
                    outputStream.write(chunk)
                }
            }

            outputStream.close()
            pendingFiles.remove(pending.fileId)
            activeTransfers.remove(pending.fileId)

            onFileComplete(pending.fileName, pending.senderId, outputFile.absolutePath)
            Log.d(TAG, "File transfer complete: ${pending.fileName}")

        } catch (e: Exception) {
            Log.e(TAG, "Failed to reconstruct file", e)
            onFileError(pending.fileId, pending.senderId, "File reconstruction failed")
        }
    }
=======
    fun receiveFileChunk(payload: Payload) {
        payload.asBytes()?.let { bytes ->
            val json = String(bytes, StandardCharsets.UTF_8)

            try {
                val chunkData = gson.fromJson(json, FileChunk::class.java)
                pendingFiles[chunkData.fileId]?.let { pending ->
                    java.io.RandomAccessFile(pending.tempFile, "rw").use { raf ->
                        raf.seek(chunkData.chunkIndex.toLong() * CHUNK_SIZE)
                        raf.write(chunkData.data)
                    }

                    pending.chunksReceived++
                    val progress = pending.chunksReceived.toFloat() / pending.totalChunks
                    onFileProgress(pending.fileName, pending.senderId, progress)

                    if (pending.chunksReceived == pending.totalChunks) {
                        finalizeFile(pending)
                    }
                }
            } catch (e: Exception) {
                try {
                    val metadata = gson.fromJson(json, FileMetadata::class.java)
                    val sanitizedFileName = File(metadata.fileName).name
                    val tempFile = File(context.cacheDir, "recv_${metadata.fileId}_$sanitizedFileName")
                    pendingFiles[metadata.fileId] = PendingFileTransfer(
                        fileId = metadata.fileId,
                        fileName = metadata.fileName,
                        totalSize = metadata.fileSize,
                        senderId = metadata.senderId,
                        totalChunks = metadata.totalChunks,
                        tempFile = tempFile
                    )
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to parse file data", e)
                }
            }
        }
    }

    private fun finalizeFile(pending: PendingFileTransfer) {
        try {
            val sanitizedFileName = File(pending.fileName).name
            val outputFile = File(context.cacheDir, "received_$sanitizedFileName")

            if (pending.tempFile.renameTo(outputFile)) {
                pendingFiles.remove(pending.fileId)
                activeTransfers.remove(pending.fileId)
                onFileComplete(pending.fileName, pending.senderId, outputFile.absolutePath)
                Log.d(TAG, "File transfer complete: ${pending.fileName}")
            } else {
                throw IOException("Failed to finalize file (rename failed)")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to finalize file", e)
            onFileError(pending.fileId, pending.senderId, "File finalization failed")
        }
    }
>>>>>>> REPLACE
